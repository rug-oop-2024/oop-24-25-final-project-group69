from typing import TypeVar
from math import pi as pinumber

class GymMember:
    course_level_conversion = {
        "easy": 1,
        "medium": 2,
        "hard": 4
    }

    def __init__(self, name_surname: str, address, email: str, courses):
        self._name_surname = name_surname
        self._address = address
        self._email = email
        self._courses = courses

    def get_score(self) -> int:
        return sum([self.course_level_conversion[course] for course in self._courses])

class PremiumGymMember(GymMember):
    def get_score(self) -> int:
        return super().get_score() + max([self.course_level_conversion[course] for course in self._courses]) + 5

my_tuple = (1,10,3,0,"abc")
print(any([element > 5 for element in my_tuple if isinstance(element, int)]))


T = TypeVar("T", bound="MergeableDict")

class MergeableDict(dict):
    def __add__(self, other_dict: dict) -> T:
        result_dict = MergeableDict({})
        
        result_dict = {key: value for key, value in self.items()}
        result_dict.update({key: value for key, value in other_dict.items() if key not in result_dict.keys()})
        
        return result_dict
    
anagraphics = MergeableDict({"name": "John", "surname": "Doe", "date of birth": "1990-07-24"})
measurements = MergeableDict({"height": 180.4, "weight": 72.2, "blood pressure": [80, 120]})

print(anagraphics + measurements)


T1 = TypeVar("T", bound="AdditiveSet")

class AdditiveSet(set):
    def __add__(self, other_set: set) -> T1:
        return self.intersection(other_set)
    

T2 = TypeVar("T", bound="SubstractableSet")

class SubstractableSet(set):
    def __sub__(self, other_set: set) -> T2:
        return self.difference(other_set)
    
set1 = AdditiveSet({1,2,3})
set2 = AdditiveSet({2})

print(set1 + set2)

set1 = SubstractableSet({1,2,3})
set2 = SubstractableSet({2})

print(set1 - set2)

#def dict_sum_of_keys(self, dictionary:dict|DictOfIntKeys) -> float:
'''
Returns the sum of the keys of the dictionary when these are numbers.
'''
   #return sum([dictionary_key for dictionary_key in dictionary.keys() if isinstance(dictionary_key, (int, float))])


class SignatureAppender:
    def __init__(self, signature: str) -> None:
        self._signature = self._set_signature(signature)

    def __call__(self, input_string: str) -> str:
        return input_string + " " + self._signature
    
    @property
    def signature(self) -> str:
        return self._signature
    
    @signature.setter
    def signature(self, value: str) -> None:
        self._signature = self._set_signature(value)
        
    def _set_signature(self, signature: str) -> str:
        """Private method to validate and set the signature."""
        if not isinstance(signature, str) or signature == "":
            raise ValueError("Signature must be a non-empty string.")
        return signature

signature_appended = (SignatureAppender("def"))("abc")

print(signature_appended)

from abc import ABC, abstractmethod

class HasHP(ABC):
    _hp: int
    
    def __init__(self, hp:str) -> None:
        self._hp = hp

class NPC(ABC):
    _name: str
    
    def __init__(self, name:str) -> None:
        self._name = name
        
    @abstractmethod
    def __str__(self) -> str:
        pass

class Healer(NPC):
    def heal(self, target:HasHP, amount:int) -> None:
        target._hp += amount
    
    def __str__(self) -> str:
        return f"Healer {self._name}"

class Enemy(NPC, HasHP):
    def __init__(self, name:str, hp:int) -> None:
        NPC.__init__(name=name)
        HasHP.__init__(hp=hp)

    def attack(self, target:HasHP, damage:int) -> None:
        target._hp -= damage
    
    def __str__(self) -> str:
        return f"Enemy {self._name} - HP: {self._hp}"
    
class BaseClass:
    def __init__(self, name):
        self.name = name
       
class LeftSubclass(BaseClass):
    def __init__(self, name):
        super().__init__(name)
       
class RightSubclass(BaseClass):
    def __init__(self, name):
        super().__init__(name)
       
class Subclass(LeftSubclass, RightSubclass):
    def __init__(self, name):
        super().__init__(name)
       
subclass = Subclass("George")
print(Subclass.__mro__)